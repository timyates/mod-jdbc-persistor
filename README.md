Slowly gaining trust...  Could do with more eyes looking at it to check its asynchronous credentials, and spot weak points or cracks...

More work probably required...

See the [current tests](https://github.com/timyates/mod-jdbc-persistor/blob/master/src/test/resources/test_client.js) for it in action though...

Default config:

    {
      address  : "com.bloidonia.jdbcpersistor",

      // JDBC connection settings
      driver   : "org.hsqldb.jdbcDriver",
      url      : "jdbc:hsqldb:mem:test",
      username : "",
      password : "",

      // Pool settings
      minpool  : 5,
      maxpool  : 20,
      acquire  : 5,

      // Defaults
      batchtimeout       : 5000,
      transactiontimeout : 10000
    }

Currently attempts to support:

# Interface Specification

This is a quick doc describing how I want it work, so I don't change my mind halfway through coding it ;-)

It may not be a description of how it currently works...

## EXECUTE

The execute action is for running parameterless SQL which does not generate a `ResultSet`

### Inputs

    {
      action: "execute",
      stmt:   "CREATE TABLE test ( id INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 1 INCREMENT BY 1) NOT NULL," +
                                 " name VARCHAR(80), age  INTEGER, CONSTRAINT testid PRIMARY KEY ( id ) )"
    }

### OUTPUTS

    {
      status: "ok"
    }

or

    {
      status: "error",
      message: <message>
    }

## SELECT

Call some SQL that generates a ResultSet.

Takes an optional list of lists (same order as the `?` placeholders) as parameters to the query.

### Inputs

    {
      action: "select",
      stmt: "SELECT * FROM xxx"
    }

or

    {
      action: "select",
      stmt: "SELECT * FROM xxx WHERE a=? AND b=?",
      params: [ [ 10, 20 ], ... ]
    }

### Outputs

One of:

    {
      status: "ok",
      result: [ { "NAME":"a", "AGE":32 }, ... ]
    }

    {
      status: "error",
      message: <message>
    }

### Response Batching

If you want the resulting list of maps to be batched into a certain number of results, you can add the parameters `batchsize` (default `-1` for no batching) and `batchtimeout` (in ms: default `10000`) to your query message.

ie; consider a table with 5 rows:

|`NAME` |
---------
|   tim |
| sarah |
|  alan |
| cerys |
|    si |

If we execute:

    {
      action: "select",
      stmt: "SELECT NAME FROM TABLENAME",
      batchsize: 3,
      batchtimeout: 10000
    }

Then the first response will be:

    {
      status: "more-exist",
      result: [ { "NAME":"tim" }, { "NAME":"sarah" }, { "NAME":"alan" } ]
    }

Along with a handler to fetch the rest of the results.  A call to this will result in the response:

    {
      status: "ok",
      result: [ { "NAME":"cerys" }, { "NAME":"si" } ]
    }

The `ok` specifying that we have reached the end of this batch.  If you do not call this batch handler within `batchtimeout` milliseconds, the ResultSet, Statement and Connection will be closed (unless you are inside a transaction (see below), in which case the Connection will remain open).

## INSERT

Takes an optional list of lists (same order as the `?` placeholders) as parameters to the query.

Returns the primary keys generated by the insert.

You may also pass the optional parameters `batchsize` and `batchtimeout` if you want these keys returned in batches as with `select`

### Inputs

    {
      action: "insert",
      stmt: "INSERT INTO xxx( a, b ) VALUES( ?, ? )",
      params: [ [ 10, 20 ], ... ]
    }

### Outputs

One of:

    {
      status: "ok",
      result: [ { "ID":1 }, { "ID":2 }, ... ]
      updated: <nrows>
    }

or

    {
      status: "error",
      message: <message>
    }

## UPDATE

### Inputs

    {
      action: "update"
      stmt: "UPDATE xxx SET( a=?, b=? ) WHERE c=?",
      params: [ [ 10, 20, 30 ], ... ]
    }

### OUTPUTS

    {
      status: "ok",
      updated: <nrows>
    }

or

    {
      status: "error",
      message: <message>
    }

## TRANSACTION

This starts an SQL transaction, and returns a handler to execute any of the above messages inside.

After each response, if no reply is heard for more than `timout` milliseconds (default `10000`), then the transaction is rolled back and the connection is closed.

Once you are done with a transaction, then handler needs to be sent a `commit` or `rollback` message (see below)

### Inputs

    {
      action: "transaction",
      timeout: 10000
    }

### OUTPUTS

    {
      status:"ok"
    }

or

    {
      status: "error",
      message: <message>
    }


## COMMIT

Inform the Transaction handler to commit any changes to the connection, and close the connection.

### Inputs

    {
      action: "commit"
    }

### OUTPUTS

    {
      status:"ok"
    }

or

    {
      status: "error",
      message: <message>
    }

## ROLLBACK

Inform the Transaction handler to rollback any changes to the connection, and close the connection.

### Inputs

    {
      action: "rollback"
    }

### OUTPUTS

    {
      status: "ok"
    }

or

    {
      status: "error",
      message: <message>
    }

## POOL STATUS

Get the current status of the pool

### Inputs

    {
      action: "pool-status"
    }

### OUTPUTS

    {
      status: "ok",
      connections: 10,
      idle: 10,
      busy: 0,
      orphans: 0
    }

or

    {
      status: "error",
      message: <message>
    }
